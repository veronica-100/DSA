    '''
    7:9 Initialize one variable to store the calculated area value, and two index pointers that point to the first (left) and last (right) data elements in the array.
    10: While the left index value is less than the right
    11: Initialize a variable to store smaller result of (min) (comparision of left/right pointer array values && returns smaller).
    12: Update area variable with larger result of (max) (comparision of current area value vs (new area value(minHeight * abs left/right pointer array values) && returns larger).
    13:16 Traverse array using left/right index pointers, comparing the corresponding array values.
    :: The larger value triggers stay at current index while smaller value triggers move to next.
    :: Repeat the process while the left index value is less than the right
    18: Return max area found.
    '''


Approach:

    Given an array of heights of lines of boundaries of the container, find the maximum water that can be stored in a container. So start with the first and last element and check the amount of water that can be contained and store that container. Now the question arises is there any better boundaries or lines that can contain maximum water. So there is a clever way to find that. Initially, there are two indices the first and last index pointing to the first and the last element (which acts as boundaries of the container), if the value of first index is less than the value of last index increase the first index else decrease the last index. As the decrease in width is constant, by following the above process the optimal answer can be reached.

Algorithm: 

    Keep two index, first = 0 and last = n-1 and a value max_area that stores the maximum area.
    Run a loop until first is less than the last.
    Update the max_area with maximum of max_area and min(array[first] , array[last])*(last-first)
    if the value at array[first] is greater the array[last] then update last as last – 1 else update first as first + 1
    Print the maximum area.

Complexity Analysis: 

    Time Complexity: O(n). 
    As only one traversal of the array is required, so time complexity is O(n).
    Space Complexity: O(1). 
    No extra space is required, so space complexity is constant.

Solution Analysis:

    Everytime, we are moving our pointer i (left) ahead if height of line at ith index is smaller or j (right) pointer if height of line at jth index is smaller. 
    This means whichever line is smaller, we won’t consider it again, because this line could be the answer only if the other line is larger than it and at maximum width and to be noticed that this is the time when other line is larger as well as max distance apart. So, not considering it makes sense.
    
    In other words, we are required to pair up every line with that line which is greater than it and at maximum distance apart i.e. 
    
    For example -> 8 5 9 1 10 2 6
    
    here, if 8 has to be in the answer then other line that we choose should be 10 as it is the first line from the end that is at maximum distance apart from 8 and longer than 8. Hence, for 8 to be in the answer, other line should be 10.
    
    Now, Lets assume i at 8 and j at 10. Compare it and move the pointer i to 5.
    
    Now, you may ask, ok, you have moved the pointer i to 5 but can it not happen that 5 could pair up with other lines after 10 as we have neglected those lines by moving j pointer to 10.
    
    So, to be noticed that if 5 would have been in the answer then any line after 10 must be >= 5 and if there is any line after 10 whose height is greater than or equal to 5 then its contribution would surely have been calculated while pointer ‘i’ was at 8.
    
    So, for the combinations of lines which we are neglecting, have been already taken care of.